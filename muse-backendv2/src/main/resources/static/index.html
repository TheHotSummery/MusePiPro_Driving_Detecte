<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RISC-V ç–²åŠ³é©¾é©¶æ£€æµ‹å¹³å° - æ™ºèƒ½é©¾é©¶èˆ±</title>
    
    <!-- å¼•å…¥ Vue 3 -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- å¼•å…¥ Element Plus (å¯é€‰ï¼Œç”¨äºå›¾æ ‡ç­‰) -->
    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css" />
    <script src="https://unpkg.com/element-plus/dist/index.full.js"></script>
    <!-- å¼•å…¥ ECharts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <!-- å¼•å…¥ TailwindCSS (å¿«é€Ÿå¸ƒå±€) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- 
        ===========================================================
        é«˜å¾·åœ°å›¾é…ç½®åŒºåŸŸ
        è¯·åœ¨æ­¤å¤„å¡«å…¥ä½ çš„ Key å’Œ å®‰å…¨å¯†é’¥
        ===========================================================
    -->
    <script type="text/javascript">
        window._AMapSecurityConfig = {
            securityJsCode: 'a0f65e66806bd8b70202e9d270bf74ca', 
        };
    </script>
    <script src="https://webapi.amap.com/maps?v=2.0&key=732a364f70864bb0c4ac3395cc3d5503"></script>

    <style>
        /* --- å…¨å±€å­—ä½“ä¸èƒŒæ™¯ --- */
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Noto+Sans+SC:wght@300;400;700&display=swap');

        body {
            background-color: #020617;
            color: #e2e8f0;
            font-family: 'Noto Sans SC', sans-serif;
            overflow: hidden; /* é˜²æ­¢æ»šåŠ¨ */
            margin: 0;
            padding: 0;
        }

        .font-tech {
            font-family: 'Rajdhani', sans-serif; /* ç§‘æŠ€æ„Ÿæ•°å­—å­—ä½“ */
        }

        /* --- ç§‘æŠ€æ„ŸèƒŒæ™¯ç½‘æ ¼åŠ¨ç”» --- */
        .bg-grid {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(0, 242, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 242, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            z-index: -1;
            animation: gridMove 20s linear infinite;
        }

        @keyframes gridMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(40px); }
        }

        /* --- ç»ç’ƒæ‹Ÿæ€å¡ç‰‡ --- */
        .glass-panel {
            background: rgba(13, 25, 48, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 242, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
            clip-path: polygon(
                0 0, 
                100% 0, 
                100% calc(100% - 20px), 
                calc(100% - 20px) 100%, 
                0 100%
            ); /* å³ä¸‹è§’åˆ‡è§’ */
        }

        /* å¡ç‰‡è£…é¥°çº¿ */
        .glass-panel::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 2px;
            background: linear-gradient(90deg, transparent, #00f2ff, transparent);
        }

        .glass-panel::after {
            content: '';
            position: absolute;
            bottom: 0; right: 0; width: 20px; height: 20px;
            border-bottom: 2px solid #00f2ff;
            border-right: 2px solid #00f2ff;
        }

        /* --- æ ‡é¢˜å…‰æ•ˆ --- */
        .header-title {
            background: linear-gradient(to bottom, #ffffff, #84ccff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(0, 242, 255, 0.5);
        }

        /* --- æ»šåŠ¨æ¡ç¾åŒ– --- */
        ::-webkit-scrollbar { width: 4px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #00f2ff; border-radius: 2px; }

        /* --- å‘Šè­¦åˆ—è¡¨åŠ¨ç”» --- */
        .alert-item {
            animation: slideIn 0.5s ease-out forwards;
        }
        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* --- åœ°å›¾å®¹å™¨ --- */
        #map-container {
            width: 100%;
            height: 100%;
            background: #050b14; /* åœ°å›¾åŠ è½½å‰çš„åº•è‰² */
        }
        
        /* è‡ªå®šä¹‰é«˜å¾·åœ°å›¾ InfoWindow */
        .amap-info-content {
            background: rgba(13, 25, 48, 0.9) !important;
            border: 1px solid #00f2ff !important;
            color: white !important;
            box-shadow: 0 0 15px #00f2ff44 !important;
        }
        .amap-info-sharp { border-top-color: #00f2ff !important; }
    </style>
</head>
<body>
    <div id="app" class="relative w-screen h-screen overflow-hidden text-sm">
        
        <!-- èƒŒæ™¯åŠ¨æ•ˆ -->
        <div class="bg-grid"></div>

        <!-- 1. é¡¶éƒ¨ Header -->
        <header class="absolute top-0 left-0 w-full h-20 z-50 flex justify-between items-center px-8 bg-gradient-to-b from-black/80 to-transparent pointer-events-none">
            <div class="flex items-center gap-4 pointer-events-auto">
                <!-- ç®€æ˜“Logo -->
                <div class="w-10 h-10 border-2 border-cyan-400 rounded-full flex items-center justify-center animate-pulse shadow-[0_0_15px_#00f2ff]">
                    <span class="font-tech font-bold text-xl text-cyan-400">R</span>
                </div>
                <div>
                    <h1 class="text-3xl font-bold header-title tracking-wider">ç–²åŠ³æ„ŸçŸ¥ä¸åˆ†çº§é¢„è­¦ç³»ç»Ÿåå°ç›‘æ§
                    </h1>
                    <p class="text-xs text-cyan-200/60 tracking-[0.2em] uppercase">Real-time Driver Monitoring System</p>
                </div>
            </div>
            
            <div class="flex items-center gap-6 pointer-events-auto">
                <div class="text-right">
                    <div class="text-2xl font-tech text-white">{{ currentTime }}</div>
                    <div class="text-xs text-gray-400">{{ currentDate }}</div>
                </div>
                <!-- çŠ¶æ€æŒ‡ç¤ºç¯ -->
                <div class="flex gap-2">
                    <span class="px-3 py-1 rounded bg-green-500/20 border border-green-500 text-green-400 text-xs">SYSTEM ONLINE</span>
                    <span class="px-3 py-1 rounded bg-blue-500/20 border border-blue-500 text-blue-400 text-xs">MAP READY</span>
                </div>
            </div>
        </header>

        <!-- 2. åœ°å›¾å±‚ (åº•å±‚) -->
        <div class="absolute inset-0 z-0">
            <div id="map-container"></div>
        </div>

        <!-- 3. å·¦ä¾§é¢æ¿ -->
        <div class="absolute left-6 top-24 bottom-6 w-80 flex flex-col gap-4 z-10 pointer-events-none">
            
            <!-- 3.1 æ ¸å¿ƒæŒ‡æ ‡ (HUDé£æ ¼) -->
            <div class="glass-panel p-4 pointer-events-auto">
                <h3 class="text-cyan-400 text-lg font-bold mb-3 border-l-4 border-cyan-400 pl-2">å®æ—¶æ¦‚è§ˆ</h3>
                <div class="grid grid-cols-2 gap-3">
                    <div class="bg-blue-900/30 p-3 rounded border border-blue-500/30">
                        <div class="text-gray-400 text-xs">åœ¨çº¿è½¦è¾†</div>
                        <div class="text-2xl font-tech text-white">{{ realtimeData.onlineVehicles }}<span class="text-sm text-gray-500">/{{ realtimeData.totalVehicles }}</span></div>
                    </div>
                    <div class="bg-red-900/30 p-3 rounded border border-red-500/30 animate-pulse">
                        <div class="text-gray-400 text-xs">æ´»è·ƒå‘Šè­¦</div>
                        <div class="text-2xl font-tech text-red-500">{{ realtimeData.activeAlerts }}</div>
                    </div>
                </div>
                <div class="mt-4">
                    <div class="flex justify-between text-xs mb-1 text-gray-300">
                        <span>ç³»ç»Ÿå¥åº·åº¦</span>
                        <span class="font-tech">98%</span>
                    </div>
                    <div class="w-full bg-gray-700 h-1 rounded-full overflow-hidden">
                        <div class="bg-gradient-to-r from-green-400 to-cyan-400 h-full w-[98%]"></div>
                    </div>
                </div>
            </div>

            <!-- 3.2 ç–²åŠ³è¶‹åŠ¿å›¾è¡¨ -->
            <div class="glass-panel p-4 flex-1 pointer-events-auto flex flex-col">
                <h3 class="text-cyan-400 text-lg font-bold mb-2 border-l-4 border-cyan-400 pl-2">ç–²åŠ³æŒ‡æ•°è¶‹åŠ¿</h3>
                <div id="chart-trend" class="flex-1 w-full"></div>
            </div>

            <!-- 3.3 è¡Œä¸ºåˆ†å¸ƒ -->
            <div class="glass-panel p-4 h-64 pointer-events-auto flex flex-col">
                <h3 class="text-cyan-400 text-lg font-bold mb-2 border-l-4 border-cyan-400 pl-2">å¼‚å¸¸è¡Œä¸ºç±»å‹</h3>
                <div id="chart-radar" class="flex-1 w-full"></div>
            </div>
        </div>

        <!-- 4. å³ä¾§é¢æ¿ -->
        <div class="absolute right-6 top-24 bottom-6 w-80 flex flex-col gap-4 z-10 pointer-events-none">
            
            <!-- 4.1 åŒºåŸŸé£é™©æ’è¡Œ -->
            <div class="glass-panel p-4 h-64 pointer-events-auto flex flex-col">
                <h3 class="text-cyan-400 text-lg font-bold mb-2 border-l-4 border-cyan-400 pl-2">åŒºåŸŸé£é™©åˆ†å¸ƒ</h3>
                <div id="chart-region" class="flex-1 w-full"></div>
            </div>

            <!-- 4.2 å®æ—¶å‘Šè­¦æµ -->
            <div class="glass-panel p-4 flex-1 pointer-events-auto overflow-hidden flex flex-col">
                <h3 class="text-cyan-400 text-lg font-bold mb-3 border-l-4 border-cyan-400 pl-2">å®æ—¶å‘Šè­¦ç›‘æ§</h3>
                <div class="overflow-y-auto flex-1 pr-2 space-y-2">
                    <div v-for="alert in alerts" :key="alert.alertId" 
                         @click="showDriverEventsOnMap(alert.driverId, alert.driverName)"
                         class="alert-item p-3 rounded bg-gradient-to-r from-gray-800 to-transparent border-l-2 cursor-pointer hover:bg-gray-700/50 transition"
                         :class="getLevelColorClass(alert.level)">
                        <div class="flex justify-between items-start mb-1">
                            <span class="font-bold text-gray-200">{{ alert.driverName }}</span>
                            <span class="font-tech text-xs px-1 rounded text-black font-bold" :class="getLevelBgClass(alert.level)">{{ alert.level }}</span>
                        </div>
                        <div class="text-xs text-gray-400 mb-1">ID: {{ alert.deviceId }}</div>
                        <div class="flex justify-between items-center text-xs">
                            <span class="text-white">{{ alert.behavior }}</span>
                            <span class="font-tech text-gray-500">{{ formatTime(alert.timestamp) }}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 5. åº•éƒ¨æ§åˆ¶æ  (å¯é€‰) -->
        <div class="absolute bottom-8 left-1/2 -translate-x-1/2 z-20 glass-panel px-8 py-2 rounded-full flex gap-8 pointer-events-auto">
            <a href="monitor.html" class="flex flex-col items-center cursor-pointer group">
                <span class="text-cyan-400 group-hover:text-white transition-colors">ğŸš—</span>
                <span class="text-[10px] text-gray-400 mt-1">è½¦è¾†ç›‘æ§</span>
            </a>
            <a href="heatmap.html" class="flex flex-col items-center cursor-pointer group">
                <span class="text-red-400 group-hover:text-white transition-colors">ğŸ”¥</span>
                <span class="text-[10px] text-gray-400 mt-1">ç–²åŠ³çƒ­åŠ›</span>
            </a>
            <a href="report.html" class="flex flex-col items-center cursor-pointer group">
                <span class="text-green-400 group-hover:text-white transition-colors">ğŸ“Š</span>
                <span class="text-[10px] text-gray-400 mt-1">æ•°æ®æŠ¥è¡¨</span>
            </a>
        </div>

    </div>

    <script>
        const { createApp, ref, onMounted, onUnmounted } = Vue;

        // APIåŸºç¡€URL
        const API_BASE = '/api/v2/dashboard';

        // --- å·¥å…·å‡½æ•°ï¼šé˜²æŠ–å’ŒèŠ‚æµ ---
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        const throttle = (func, limit) => {
            let inThrottle;
            return function(...args) {
                if (!inThrottle) {
                    func.apply(this, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        };

        // --- æœ¬åœ°ç¼“å­˜ç®¡ç† ---
        const cacheManager = {
            cache: new Map(),
            maxAge: 30000, // 30ç§’ç¼“å­˜
            maxSize: 100, // æœ€å¤šç¼“å­˜100æ¡
            
            get(key) {
                const item = this.cache.get(key);
                if (!item) return null;
                if (Date.now() - item.timestamp > this.maxAge) {
                    this.cache.delete(key);
                    return null;
                }
                return item.data;
            },
            
            set(key, data) {
                // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œåˆ é™¤æœ€æ—§çš„
                if (this.cache.size >= this.maxSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }
                this.cache.set(key, {
                    data,
                    timestamp: Date.now()
                });
            },
            
            generateKey(url, params) {
                return `${url}_${JSON.stringify(params)}`;
            }
        };

        createApp({
            setup() {
                // --- çŠ¶æ€æ•°æ® ---
                const currentTime = ref('');
                const currentDate = ref('');
                const realtimeData = ref({
                    totalVehicles: 0,
                    onlineVehicles: 0,
                    activeAlerts: 0
                });
                const alerts = ref([]);
                const trendData = ref([]);
                const behaviorData = ref({});
                const regionData = ref([]);

                // --- åœ°å›¾å®ä¾‹ ---
                let map = null;
                let markers = [];
                let eventMarkers = []; // äº‹ä»¶æ ‡è®°æ•°ç»„
                let mapMoveTimer = null;
                let isMapMoving = false;
                let lastMapBounds = null;
                const MAP_UPDATE_DELAY = 800; // åœ°å›¾åœæ­¢ç§»åŠ¨å800msæ‰æ›´æ–°
                const MAP_MOVE_THRESHOLD = 0.01; // åœ°å›¾ç§»åŠ¨è¶…è¿‡0.01åº¦æ‰æ›´æ–°

                // --- å·¥å…·å‡½æ•° ---
                const formatTime = (ts) => {
                    const d = new Date(ts);
                    return `${d.getHours().toString().padStart(2,'0')}:${d.getMinutes().toString().padStart(2,'0')}`;
                };

                const updateTime = () => {
                    const now = new Date();
                    currentTime.value = now.toLocaleTimeString('en-GB'); // 24h format
                    currentDate.value = now.toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
                };

                const getLevelColorClass = (level) => {
                    if (level === 'Level 3') return 'border-red-500';
                    if (level === 'Level 2') return 'border-orange-500';
                    return 'border-yellow-400';
                };

                const getLevelBgClass = (level) => {
                    if (level === 'Level 3') return 'bg-red-500';
                    if (level === 'Level 2') return 'bg-orange-500';
                    return 'bg-yellow-400';
                };

                // --- API æ•°æ®è·å–ï¼ˆå¸¦ç¼“å­˜ï¼‰ ---
                const fetchWithCache = async (url, params = {}) => {
                    const cacheKey = cacheManager.generateKey(url, params);
                    const cached = cacheManager.get(cacheKey);
                    if (cached) {
                        return cached;
                    }
                    
                    try {
                        const queryString = new URLSearchParams(params).toString();
                        const fullUrl = queryString ? `${url}?${queryString}` : url;
                        const response = await fetch(fullUrl);
                        const data = await response.json();
                        cacheManager.set(cacheKey, data);
                        return data;
                    } catch (error) {
                        console.error('APIè¯·æ±‚å¤±è´¥:', error);
                        throw error;
                    }
                };

                const fetchRealtimeData = async () => {
                    try {
                        // è·å–å®æ—¶è½¦è¾†çŠ¶æ€ï¼ˆä¸ä½¿ç”¨ç¼“å­˜ï¼Œå› ä¸ºéœ€è¦å®æ—¶æ€§ï¼‰
                        const vehiclesRes = await fetch(`${API_BASE}/realtime/vehicles`);
                        const vehiclesData = await vehiclesRes.json();
                        if (vehiclesData.code === 200 && vehiclesData.data) {
                            realtimeData.value.totalVehicles = vehiclesData.data.totalVehicles || 0;
                            realtimeData.value.onlineVehicles = vehiclesData.data.onlineVehicles || 0;
                        }

                        // è·å–å®æ—¶å‘Šè­¦ï¼ˆä¸ä½¿ç”¨ç¼“å­˜ï¼‰
                        const alertsRes = await fetch(`${API_BASE}/realtime/alerts`);
                        const alertsData = await alertsRes.json();
                        if (alertsData.code === 200 && alertsData.data) {
                            alerts.value = (alertsData.data.alerts || []).slice(0, 20).map(a => ({
                                alertId: a.eventId || a.alertId,
                                driverId: a.driverId || '',
                                driverName: a.driverName || 'æœªçŸ¥',
                                deviceId: a.deviceId || '',
                                level: a.level || 'Normal',
                                behavior: a.behavior || 'æœªçŸ¥è¡Œä¸º',
                                timestamp: a.timestamp || Date.now(),
                                location: a.location || null,
                                score: a.score || 0
                            }));
                            realtimeData.value.activeAlerts = alerts.value.length;
                        }
                    } catch (error) {
                        console.error('è·å–å®æ—¶æ•°æ®å¤±è´¥:', error);
                    }
                };

                const fetchChartData = async () => {
                    try {
                        const now = Date.now();
                        const startTime = now - 24 * 60 * 60 * 1000; // æœ€è¿‘24å°æ—¶

                        // è·å–è¶‹åŠ¿æ•°æ®ï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
                        const trendData_res = await fetchWithCache(`${API_BASE}/charts/trend`, {
                            startTime,
                            endTime: now,
                            interval: 'hour'
                        });
                        if (trendData_res.code === 200 && trendData_res.data) {
                            trendData.value = trendData_res.data.series?.[0]?.data || [];
                        }

                        // è·å–è¡Œä¸ºåˆ†å¸ƒï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
                        const behaviorData_res = await fetchWithCache(`${API_BASE}/charts/behaviorDistribution`, {
                            startTime,
                            endTime: now
                        });
                        if (behaviorData_res.code === 200 && behaviorData_res.data) {
                            behaviorData.value = behaviorData_res.data.distribution || {};
                        }

                        // è·å–åŒºåŸŸåˆ†å¸ƒï¼ˆä½¿ç”¨ç¼“å­˜ï¼‰
                        const regionData_res = await fetchWithCache(`${API_BASE}/charts/regionDistribution`, {
                            startTime,
                            endTime: now
                        });
                        if (regionData_res.code === 200 && regionData_res.data) {
                            // åç«¯è¿”å›çš„æ˜¯dataå­—æ®µï¼Œä¸æ˜¯distribution
                            regionData.value = regionData_res.data.data || regionData_res.data.distribution || [];
                        }
                    } catch (error) {
                        console.error('è·å–å›¾è¡¨æ•°æ®å¤±è´¥:', error);
                    }
                };

                // --- ECharts åˆå§‹åŒ– ---
                let trendChart, radarChart, regionChart;
                const initCharts = () => {
                    // 1. è¶‹åŠ¿å›¾ (æŠ˜çº¿)
                    trendChart = echarts.init(document.getElementById('chart-trend'));
                    updateTrendChart();

                    // 2. è¡Œä¸ºé›·è¾¾å›¾
                    radarChart = echarts.init(document.getElementById('chart-radar'));
                    updateRadarChart();

                    // 3. åŒºåŸŸæ’è¡Œ (æ¨ªå‘æŸ±çŠ¶å›¾)
                    regionChart = echarts.init(document.getElementById('chart-region'));
                    updateRegionChart();

                    window.addEventListener('resize', () => {
                        trendChart?.resize();
                        radarChart?.resize();
                        regionChart?.resize();
                    });
                };

                const updateTrendChart = () => {
                    if (!trendChart) return;
                    const xData = trendData.value.map(d => {
                        const date = new Date(d.timestamp);
                        return `${date.getHours()}:${String(date.getMinutes()).padStart(2, '0')}`;
                    });
                    const yData = trendData.value.map(d => d.value || 0);

                    trendChart.setOption({
                        tooltip: { trigger: 'axis', backgroundColor: 'rgba(0,0,0,0.7)', borderColor: '#00f2ff', textStyle: { color: '#fff' } },
                        grid: { top: 10, right: 10, bottom: 20, left: 30, containLabel: true },
                        xAxis: { 
                            type: 'category', 
                            data: xData.length > 0 ? xData : ['10:00', '10:05', '10:10', '10:15', '10:20', '10:25'],
                            axisLine: { lineStyle: { color: '#334155' } },
                            axisLabel: { color: '#94a3b8' }
                        },
                        yAxis: { 
                            type: 'value', 
                            splitLine: { lineStyle: { color: '#1e293b', type: 'dashed' } },
                            axisLabel: { color: '#94a3b8' }
                        },
                        series: [{
                            data: yData.length > 0 ? yData : [45, 55, 82, 60, 70, 90],
                            type: 'line',
                            smooth: true,
                            symbol: 'none',
                            lineStyle: { color: '#00f2ff', width: 3 },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(0, 242, 255, 0.5)' },
                                    { offset: 1, color: 'rgba(0, 242, 255, 0)' }
                                ])
                            }
                        }]
                    });
                };

                const updateRadarChart = () => {
                    if (!radarChart) return;
                    const behaviorNames = ['eyes_closed', 'yarning', 'head_down', 'seeing_left', 'seeing_right'];
                    const behaviorLabels = ['é—­çœ¼', 'æ‰“å“ˆæ¬ ', 'ä½å¤´', 'å·¦çœ‹', 'å³çœ‹'];
                    const values = behaviorNames.map(name => behaviorData.value[name] || 0);

                    radarChart.setOption({
                        radar: {
                            indicator: behaviorLabels.map(label => ({ name: label, max: 100 })),
                            splitArea: { areaStyle: { color: ['rgba(13, 25, 48, 0.6)', 'rgba(13, 25, 48, 0.8)'] } },
                            axisLine: { lineStyle: { color: '#334155' } },
                            splitLine: { lineStyle: { color: '#334155' } },
                            name: { textStyle: { color: '#00f2ff' } }
                        },
                        series: [{
                            type: 'radar',
                            data: [{
                                value: values.length > 0 ? values : [80, 50, 60, 30, 20],
                                name: 'è¡Œä¸ºç»Ÿè®¡',
                                itemStyle: { color: '#ff4d4f' },
                                areaStyle: { color: 'rgba(255, 77, 79, 0.4)' }
                            }]
                        }]
                    });
                };

                const updateRegionChart = () => {
                    if (!regionChart) return;
                    const topRegions = regionData.value.slice(0, 10);
                    const names = topRegions.map(r => r.regionName || 'æœªçŸ¥åŒºåŸŸ');
                    // åç«¯è¿”å›çš„æ˜¯countå­—æ®µï¼Œä¸æ˜¯eventCount
                    const values = topRegions.map(r => r.count || r.eventCount || 0);

                    regionChart.setOption({
                        grid: { top: 0, right: 20, bottom: 20, left: 10, containLabel: true },
                        xAxis: { type: 'value', show: false },
                        yAxis: { 
                            type: 'category', 
                            data: names.length > 0 ? names : ['é¼“æ¥¼åŒº', 'ç§¦æ·®åŒº', 'å»ºé‚ºåŒº', 'ç„æ­¦åŒº'],
                            axisLine: { show: false },
                            axisTick: { show: false },
                            axisLabel: { color: '#fff' }
                        },
                        series: [{
                            type: 'bar',
                            data: values.length > 0 ? values : [45, 60, 75, 82],
                            barWidth: 10,
                            itemStyle: {
                                borderRadius: [0, 5, 5, 0],
                                color: new echarts.graphic.LinearGradient(1, 0, 0, 0, [
                                    { offset: 0, color: '#ff4d4f' },
                                    { offset: 1, color: '#8b0000' }
                                ])
                            },
                            label: { show: true, position: 'right', color: '#fff', formatter: '{c}' }
                        }]
                    });
                };

                // --- åœ°å›¾åˆå§‹åŒ– ---
                const initMap = () => {
                    if (!window.AMap) {
                        console.error("é«˜å¾·åœ°å›¾APIæœªåŠ è½½ï¼Œè¯·æ£€æŸ¥Keyé…ç½®");
                        return;
                    }

                    map = new AMap.Map('map-container', {
                        resizeEnable: true,
                        center: [118.7969, 32.0603], // å—äº¬åæ ‡
                        zoom: 11,
                        pitch: 50, // 3D è§†è§’
                        viewMode: '3D',
                        mapStyle: 'amap://styles/darkblue', // æå¤œè“é£æ ¼
                    });

                    // åŠ è½½è½¦è¾†æ ‡è®°ï¼ˆå¸¦ç¼“å­˜å’Œé˜²æŠ–ï¼‰
                    const loadVehicles = async (useCache = true) => {
                        try {
                            // è·å–å½“å‰åœ°å›¾è¾¹ç•Œ
                            const bounds = map.getBounds();
                            const boundsStr = bounds ? `${bounds.getSouthWest().lng},${bounds.getSouthWest().lat},${bounds.getNorthEast().lng},${bounds.getNorthEast().lat}` : '';
                            
                            // æ£€æŸ¥è¾¹ç•Œæ˜¯å¦å˜åŒ–è¶³å¤Ÿå¤§
                            if (lastMapBounds && bounds) {
                                const sw = bounds.getSouthWest();
                                const ne = bounds.getNorthEast();
                                const lastSw = lastMapBounds.getSouthWest();
                                const lastNe = lastMapBounds.getNorthEast();
                                
                                const latDiff = Math.abs(sw.lat - lastSw.lat) + Math.abs(ne.lat - lastNe.lat);
                                const lngDiff = Math.abs(sw.lng - lastSw.lng) + Math.abs(ne.lng - lastNe.lng);
                                
                                // å¦‚æœç§»åŠ¨è·ç¦»å°äºé˜ˆå€¼ï¼Œä¸”ä½¿ç”¨ç¼“å­˜ï¼Œåˆ™è·³è¿‡
                                if (useCache && latDiff < MAP_MOVE_THRESHOLD && lngDiff < MAP_MOVE_THRESHOLD) {
                                    return;
                                }
                            }
                            
                            lastMapBounds = bounds;
                            
                            // ä½¿ç”¨ç¼“å­˜è·å–æ•°æ®
                            const data = useCache ? 
                                await fetchWithCache(`${API_BASE}/map/vehicles`, { bounds: boundsStr }) :
                                await (await fetch(`${API_BASE}/map/vehicles${boundsStr ? '?bounds=' + boundsStr : ''}`)).json();
                            
                            if (data.code === 200 && data.data && data.data.vehicles) {
                                // æ¸…é™¤æ—§æ ‡è®°
                                markers.forEach(m => map.remove(m));
                                markers = [];

                                data.data.vehicles.forEach(vehicle => {
                                    if (vehicle.location && vehicle.location.lat && vehicle.location.lng) {
                                        const content = `
                                            <div style="position:relative;">
                                                <div style="width:16px;height:16px;background:#00f2ff;border-radius:50%;box-shadow:0 0 10px #00f2ff; border:2px solid white;"></div>
                                                <div style="position:absolute;top:-30px;left:-20px;background:rgba(0,0,0,0.7);color:#00f2ff;padding:2px 5px;border:1px solid #00f2ff;font-size:10px;white-space:nowrap;">
                                                    ${vehicle.deviceId || 'UNKNOWN'}
                                                </div>
                                            </div>
                                        `;
                                        
                                        const marker = new AMap.Marker({
                                            position: [vehicle.location.lng, vehicle.location.lat],
                                            content: content,
                                            offset: new AMap.Pixel(-8, -8),
                                            map: map
                                        });
                                        
                                        // æ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œæ‰“å¼€å†å²è½¨è¿¹
                                        marker.on('click', () => {
                                            if (vehicle.deviceId) {
                                                // è·³è½¬åˆ°è½¨è¿¹å›æ”¾é¡µé¢ï¼Œä¼ é€’è®¾å¤‡ID
                                                window.location.href = `heatmap.html?deviceId=${vehicle.deviceId}&mode=track`;
                                            }
                                        });
                                        
                                        markers.push(marker);
                                    }
                                });
                            }
                        } catch (error) {
                            console.error('åŠ è½½è½¦è¾†æ•°æ®å¤±è´¥:', error);
                        }
                    };

                    // é˜²æŠ–ç‰ˆæœ¬çš„åŠ è½½å‡½æ•°
                    const debouncedLoadVehicles = debounce(() => {
                        isMapMoving = false;
                        loadVehicles(true); // ä½¿ç”¨ç¼“å­˜
                    }, MAP_UPDATE_DELAY);

                    // èŠ‚æµç‰ˆæœ¬çš„åŠ è½½å‡½æ•°ï¼ˆç”¨äºæ‹–åŠ¨è¿‡ç¨‹ä¸­ï¼‰
                    const throttledLoadVehicles = throttle(() => {
                        if (!isMapMoving) {
                            isMapMoving = true;
                        }
                    }, 200);

                    // åœ°å›¾ç§»åŠ¨å¼€å§‹
                    map.on('movestart', () => {
                        isMapMoving = true;
                        if (mapMoveTimer) clearTimeout(mapMoveTimer);
                    });

                    // åœ°å›¾ç§»åŠ¨ä¸­ï¼ˆèŠ‚æµï¼‰
                    map.on('moveend', () => {
                        throttledLoadVehicles();
                        // ç§»åŠ¨ç»“æŸåï¼Œç­‰å¾…ä¸€æ®µæ—¶é—´å†åŠ è½½ï¼ˆé˜²æŠ–ï¼‰
                        debouncedLoadVehicles();
                    });

                    // åœ°å›¾ç¼©æ”¾ï¼ˆé˜²æŠ–ï¼‰
                    map.on('zoomend', debouncedLoadVehicles);

                    // åœ°å›¾æ‹–æ‹½ç»“æŸï¼ˆé˜²æŠ–ï¼‰
                    map.on('dragend', debouncedLoadVehicles);
                    
                    // åˆå§‹åŠ è½½
                    setTimeout(() => loadVehicles(false), 1000); // é¦–æ¬¡åŠ è½½ä¸ä½¿ç”¨ç¼“å­˜
                    
                    // å®šæœŸæ›´æ–°è½¦è¾†ä½ç½®ï¼ˆä¸ä½¿ç”¨ç¼“å­˜ï¼Œç¡®ä¿æ•°æ®æ–°é²œï¼‰
                    setInterval(() => {
                        if (!isMapMoving) {
                            loadVehicles(false);
                        }
                    }, 30000); // æ¯30ç§’æ›´æ–°ä¸€æ¬¡ï¼ˆé™ä½é¢‘ç‡ï¼‰
                };

                // --- å®æ—¶æ•°æ®æ›´æ–°ï¼ˆèŠ‚æµï¼‰ ---
                let dataTimer = null;
                const startDataUpdate = () => {
                    // ç«‹å³è·å–ä¸€æ¬¡æ•°æ®
                    fetchRealtimeData();
                    fetchChartData();
                    
                    // å®šæœŸæ›´æ–°æ•°æ®ï¼ˆä½¿ç”¨èŠ‚æµï¼Œé™ä½é¢‘ç‡ï¼‰
                    dataTimer = setInterval(() => {
                        fetchRealtimeData(); // å®æ—¶æ•°æ®ä¸ä½¿ç”¨ç¼“å­˜
                        fetchChartData(); // å›¾è¡¨æ•°æ®ä½¿ç”¨ç¼“å­˜
                        // æ›´æ–°å›¾è¡¨
                        updateTrendChart();
                        updateRadarChart();
                        updateRegionChart();
                    }, 20000); // æ¯20ç§’æ›´æ–°ä¸€æ¬¡ï¼ˆé™ä½é¢‘ç‡ï¼‰
                };

                onMounted(() => {
                    setInterval(updateTime, 1000);
                    updateTime();
                    initMap();
                    initCharts();
                    startDataUpdate();
                });

                onUnmounted(() => {
                    if (dataTimer) clearInterval(dataTimer);
                    if (map) map.destroy();
                });

                // æ˜¾ç¤ºé©¾é©¶å‘˜çš„æ‰€æœ‰äº‹ä»¶åœ¨åœ°å›¾ä¸Š
                const showDriverEventsOnMap = async (driverId, driverName) => {
                    if (!driverId || !map) {
                        alert('æ— æ³•è·å–é©¾é©¶å‘˜ä¿¡æ¯');
                        return;
                    }
                    
                    try {
                        // æ¸…é™¤æ—§çš„äº‹ä»¶æ ‡è®°
                        eventMarkers.forEach(marker => map.remove(marker));
                        eventMarkers = [];
                        
                        // è·å–æœ€è¿‘24å°æ—¶å†…è¯¥é©¾é©¶å‘˜çš„æ‰€æœ‰å‘Šè­¦äº‹ä»¶
                        const now = Date.now();
                        const startTime = now - 24 * 60 * 60 * 1000;
                        const alertsRes = await fetch(`${API_BASE}/realtime/alerts`);
                        const alertsData = await alertsRes.json();
                        
                        if (alertsData.code === 200 && alertsData.data && alertsData.data.alerts) {
                            // ç­›é€‰è¯¥é©¾é©¶å‘˜çš„äº‹ä»¶
                            const driverEvents = alertsData.data.alerts.filter(a => a.driverId === driverId);
                            
                            if (driverEvents.length === 0) {
                                alert(`æœªæ‰¾åˆ°é©¾é©¶å‘˜ ${driverName} çš„æœ€è¿‘äº‹ä»¶`);
                                return;
                            }
                                
                                // åœ¨åœ°å›¾ä¸Šæ ‡æ³¨äº‹ä»¶
                                driverEvents.forEach(event => {
                                    if (event.location && event.location.lat != null && event.location.lng != null) {
                                        // å¤„ç†BigDecimalç±»å‹æˆ–æ™®é€šæ•°å­—
                                        let lat = event.location.lat;
                                        let lng = event.location.lng;
                                        
                                        // å¦‚æœæ˜¯å¯¹è±¡ï¼ˆBigDecimalï¼‰ï¼Œè½¬æ¢ä¸ºæ•°å­—
                                        if (typeof lat === 'object' && lat !== null) {
                                            lat = parseFloat(lat.toString());
                                        }
                                        if (typeof lng === 'object' && lng !== null) {
                                            lng = parseFloat(lng.toString());
                                        }
                                        
                                        if (isNaN(lat) || isNaN(lng)) {
                                            console.warn('æ— æ•ˆçš„åæ ‡:', event.location);
                                            return;
                                        }
                                        
                                        // æ ¹æ®çº§åˆ«è®¾ç½®é¢œè‰²
                                        let color = '#ffd700'; // Level 1 - é»„è‰²
                                        let size = 12;
                                        if (event.level === 'Level 3') {
                                            color = '#ff0000'; // Level 3 - çº¢è‰²
                                            size = 16;
                                        } else if (event.level === 'Level 2') {
                                            color = '#ff8c00'; // Level 2 - æ©™è‰²
                                            size = 14;
                                        }
                                        
                                        const marker = new AMap.Marker({
                                            position: [lng, lat],
                                            icon: new AMap.Icon({
                                                size: new AMap.Size(size, size),
                                                image: `data:image/svg+xml;base64,${btoa(`<svg width="${size}" height="${size}" xmlns="http://www.w3.org/2000/svg"><circle cx="${size/2}" cy="${size/2}" r="${size/2-1}" fill="${color}" stroke="#fff" stroke-width="1"/></svg>`)}`,
                                                imageSize: new AMap.Size(size, size)
                                            }),
                                            title: `${event.behavior || 'æœªçŸ¥'} - ${event.level || 'Normal'}`,
                                            zIndex: 200,
                                            map: map
                                        });
                                        
                                        // æ·»åŠ ç‚¹å‡»äº‹ä»¶æ˜¾ç¤ºè¯¦æƒ…
                                        marker.on('click', () => {
                                            const infoWindow = new AMap.InfoWindow({
                                                content: `
                                                    <div style="color: #fff; padding: 8px; min-width: 200px;">
                                                        <div style="font-weight: bold; margin-bottom: 4px; color: #00f2ff;">${driverName || 'æœªçŸ¥'}</div>
                                                        <div style="font-size: 12px; color: #ccc; margin-bottom: 2px;">è¡Œä¸º: ${event.behavior || 'æœªçŸ¥'}</div>
                                                        <div style="font-size: 12px; color: #ccc; margin-bottom: 2px;">çº§åˆ«: ${event.level || 'Normal'}</div>
                                                        <div style="font-size: 12px; color: #ccc; margin-bottom: 2px;">åˆ†æ•°: ${event.score ? event.score.toFixed(1) : '0'}</div>
                                                        <div style="font-size: 12px; color: #ccc;">æ—¶é—´: ${formatTime(event.timestamp)}</div>
                                                    </div>
                                                `,
                                                offset: new AMap.Pixel(0, -10)
                                            });
                                            infoWindow.open(map, marker.getPosition());
                                        });
                                        
                                        eventMarkers.push(marker);
                                    }
                                });
                                
                                // è°ƒæ•´åœ°å›¾è§†é‡ä»¥æ˜¾ç¤ºæ‰€æœ‰äº‹ä»¶
                                if (eventMarkers.length > 0) {
                                    map.setFitView(eventMarkers);
                                    console.log(`å·²åœ¨åœ°å›¾ä¸Šæ ‡æ³¨ ${eventMarkers.length} ä¸ªäº‹ä»¶`);
                                } else {
                                    alert('äº‹ä»¶æ•°æ®ä¸­æ²¡æœ‰ä½ç½®ä¿¡æ¯');
                                }
                        } else {
                            alert('è·å–äº‹ä»¶æ•°æ®å¤±è´¥');
                        }
                    } catch (error) {
                        console.error('è·å–é©¾é©¶å‘˜äº‹ä»¶å¤±è´¥:', error);
                        alert('è·å–äº‹ä»¶æ•°æ®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•: ' + error.message);
                    }
                };
                
                const toggleLayer = (layerName) => {
                    console.log('Toggle Layer:', layerName);
                    if (layerName === 'vehicles') {
                        // åˆ‡æ¢è½¦è¾†æ ‡è®°æ˜¾ç¤º/éšè—
                        if (markers && markers.length > 0) {
                            const isVisible = markers[0].getMap() !== null;
                            markers.forEach(marker => {
                                if (isVisible) {
                                    marker.hide();
                                } else {
                                    marker.show();
                                }
                            });
                        }
                    } else if (layerName === 'heatmap') {
                        // è·³è½¬åˆ°çƒ­åŠ›å›¾é¡µé¢
                        window.location.href = 'heatmap.html';
                    }
                };

                return {
                    currentTime,
                    currentDate,
                    realtimeData,
                    alerts,
                    formatTime,
                    getLevelColorClass,
                    getLevelBgClass,
                    toggleLayer,
                    showDriverEventsOnMap
                };
            }
        }).mount('#app');
    </script>
</body>
</html>